
# AI Agent Workflow Log

This document details the usage of AI agents, specifically GitHub Copilot, in the development of the FuelEU Maritime compliance platform, adhering to the assignment's constraints.

## Agents Used

As per the assignment requirements, the **only** AI agent used for code generation, refactoring, and testing was **GitHub Copilot**.

This was utilized in three primary modes:

  * **Inline Completions:** (Grey-text suggestions triggered by `Tab`) for boilerplate, variable names, and simple function bodies.
  * **Copilot Chat (IDE View):** (The side-panel chat) for project-wide tasks, scaffolding new files (`@workspace /new`), and generating tests (`@workspace /tests`).
  * **Copilot Chat (Inline `Ctrl+I`):** For context-specific generation, refactoring, or explaining code blocks.

-----

## Prompts & Outputs

Below are representative examples of the prompt-and-generation workflow.

### Example 1: Generating a Core Use Case (Backend)

**Context:** Implementing the core business logic for calculating Compliance Balance (CB) within the hexagonal architecture. The goal was to generate the use case file in `backend/src/core/application/`.

**Prompt (to Copilot Chat `@workspace`):**

```
> @workspace Create a 'ComputeComplianceBalanceUseCase' class. It should implement an 'execute(shipId, year)' method.
Constants:
- TARGET_INTENSITY = 89.3368
- ENERGY_PER_TON = 41000

Formula:
ComplianceBalance = (TARGET_INTENSITY - actual_ghgIntensity) * (fuelConsumption * ENERGY_PER_TON)

Inject 'IRouteRepository' and 'IComplianceRepository' via the constructor.
The 'execute' method should:
1. Fetch the relevant route data (ghgIntensity, fuelConsumption) using IRouteRepository for the given ship and year.
2. Calculate the Compliance Balance (CB).
3. Save the result using IComplianceRepository.
4. Return the calculated CB.
```

**Generated Output (Snippet):**

```typescript
// Generated by Copilot (in backend/src/core/application/computeComplianceBalance.usecase.ts)
import { IRouteRepository } from '../ports/route.repository';
import { IComplianceRepository } from '../ports/compliance.repository';

// Constants were hardcoded, which I later refactored
const TARGET_INTENSITY = 89.3368;
const ENERGY_PER_TON = 41000;

export class ComputeComplianceBalanceUseCase {
  constructor(
    private routeRepository: IRouteRepository,
    private complianceRepository: IComplianceRepository
  ) {}

  async execute(shipId: string, year: number): Promise<number> {
    // Copilot correctly identified the need to fetch data first
    const route = await this.routeRepository.findRouteForShip(shipId, year); // This method name was a guess

    if (!route) {
      throw new Error('Route data not found for ship and year');
    }

    const energyInScope = route.fuelConsumption * ENERGY_PER_TON;
    const complianceBalance =
      (TARGET_INTENSITY - route.ghgIntensity) * energyInScope;

    // Correctly used the compliance repository to save
    await this.complianceRepository.saveSnapshot({
      shipId,
      year,
      cb_gco2eq: complianceBalance,
    });

    return complianceBalance;
  }
}
```

-----

### Example 2: Scaffolding a UI Component (Frontend)

**Context:** Building the 'Routes' tab component, including data fetching and table display.

**Prompt (to Copilot Chat `@workspace`):**

```
> @workspace Create a 'RoutesTab' component using React and Tailwind.
1. Use the 'useRoutes' custom hook to fetch data.
2. While 'loading', show a 'LoadingSpinner' component.
3. If 'error', show an error message.
4. Render a table styled with Tailwind (dark/light mode compatible).
5. Columns: routeId, vesselType, fuelType, year, ghgIntensity, totalEmissions.
6. Add a 'Set Baseline' button in each row.
```

**Generated Output (Snippet):**

```tsx
// Generated by Copilot (in frontend/src/adapters/ui/components/RoutesTab.tsx)
import React from 'react';
import { useRoutes } from '../../../core/application/useRoutes';
import { LoadingSpinner } from './LoadingSpinner'; // Assumed this component exists

export const RoutesTab: React.FC = () => {
  const { routes, loading, error, setBaseline } = useRoutes(); // Guessed 'setBaseline'

  if (loading) {
    return <LoadingSpinner />;
  }

  if (error) {
    return <div className="text-red-500">Error: {error.message}</div>;
  }

  const handleSetBaseline = (routeId: string) => {
    // TODO: Wire this up
    console.log('Set baseline for', routeId);
    // setBaseline(routeId); // This was the intended, but un-implemented, call
  };

  return (
    <div className="p-4 overflow-x-auto">
      <table className="min-w-full divide-y divide-gray-200 dark:divide-gray-700">
        <thead className="bg-gray-50 dark:bg-gray-800">
          <tr>
            <th className="px-6 py-3 ...">Route ID</th>
            {/* ... other headers ... */}
            <th className="px-6 py-3 ...">Actions</th>
          </tr>
        </thead>
        <tbody className="bg-white divide-y divide-gray-200 dark:bg-gray-900 dark:divide-gray-700">
          {routes.map((route) => (
            <tr key={route.routeId}>
              <td className="px-6 py-4 ...">{route.routeId}</td>
              {/* ... other cells ... */}
              <td className="px-6 py-4">
                <button
                  onClick={() => handleSetBaseline(route.routeId)}
                  className="px-4 py-2 font-medium text-white bg-blue-600 rounded-md hover:bg-blue-700"
                >
                  Set Baseline
                </button>
              </td>
            </tr>
          ))}
        </tbody>
      </table>
    </div>
  );
};
```

-----

## Validation / Corrections

Copilot was a "pair programmer" that required active supervision. My skill was applied in validating and correcting its output.

  * **On Example 1 (Backend):**

      * **Correction:** Copilot's `routeRepository.findRouteForShip` was a good *guess*, but it wasn't the method name defined in my `IRouteRepository` port.
      * **My Fix:** I manually refactored the call to match my port's actual method (`findByShipAndYear`).
      * **My Fix:** The hardcoded constants (`TARGET_INTENSITY`, `ENERGY_PER_TON`) were immediately extracted into a `src/shared/constants.ts` file to maintain clean architecture principles. Copilot just dumped them in the file.

  * **On Example 2 (Frontend):**

      * **Correction:** The `handleSetBaseline` function was a stub. Copilot created the button but didn't know *how* to implement the mutation.
      * **My Fix:** I manually created a `useSetBaseline` mutation hook (using `useSWR` or `react-query` patterns) and wired it to the `onClick` handler, including a re-fetch of the routes data upon success.
      * **My Fix:** Copilot assumed a `LoadingSpinner` component. I had to use an inline prompt (`// create a simple tailwind css spinning loader`) to generate that component separately.

-----

## Observations

### Where Copilot Saved Time

  * **TDD:** `> @workspace /tests Generate unit tests for 'ComputeComplianceBalanceUseCase'` was a huge accelerator. It generated the `describe/it` blocks and mocked all dependencies (repositories) perfectly. I only had to fill in the specific `expect` assertions.
  * **Boilerplate:** Scaffolding `package.json`, `tsconfig.json`, `vite.config.ts`, `prisma.schema.prisma`, and the basic Express `index.ts` server was instantaneous.
  * **Repository Implementation:** After defining the `IRouteRepository` port, I prompted Copilot to implement the adapter (`PrismaRouteRepository`). It correctly inferred all the Prisma Client calls (`prisma.route.findMany`, `prisma.route.update`) from the port's method signatures.
  * **Tailwind:** Generating the Tailwind markup for tables and forms (Example 2) was incredibly fast and saved significant time over manual class writing.

### Where Copilot Failed or Hallucinated

  * **Complex Domain Logic:** Copilot consistently failed on the **Pooling (Article 21)** logic. My prompts for the "greedy allocation algorithm" produced `for` loops that were either simplistic, inefficient (O(n^2)), or outright wrong. They did not satisfy the constraints (e.g., "deficit ship cannot exit worse"). This core piece of logic had to be written almost entirely manually.
  * **Architectural Nuance:** It sometimes tried to "cheat" the hexagonal architecture. For example, it once suggested importing the `PrismaClient` (an adapter) directly into a `core` use case file, which I had to immediately correct.
  * **Test Edge Cases:** It's excellent at "happy path" tests. It's poor at generating tests for edge cases (e.g., empty arrays, division by zero in the Compare tab, invalid pool combinations, over-applying a bank surplus). I had to manually add all of these.

-----

## Best Practices Followed

1.  **Architecture-First, AI-Second:** I manually created the hexagonal folder structure (`core/`, `adapters/`, `infrastructure/`) *before* invoking `@workspace`. This provided the necessary context for Copilot to place files correctly and understand the dependency flow.
2.  **Port-Driven Development:** I always manually wrote the `port` (interface) first. Then, I used Copilot to generate both the *use case* (which consumed the port) and the *adapter* (which implemented the port). This kept the AI aligned with the architecture.
3.  **Specific, Contextual Prompts:** I avoided vague prompts like "build the app." Instead, I used highly specific, task-oriented prompts (as shown in the examples) that defined *what* to build, *where* it fit, and *what* logic it should contain.
4.  **TDD with AI:** My workflow was:
    a. Manually write the port interface.
    b. Use Copilot Chat (`@workspace /tests`) to generate the test file for a use case.
    c. Run the test (which failed).
    d. Use Copilot Chat (`@workspace`) to generate the use case implementation to make the test pass.
    e. Manually add edge case tests.